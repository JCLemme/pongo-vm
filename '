;; Convert a number to chunks/bytes for the Pongo VM
;; Takes: 16-bit fixnum
;; Returns: list of 8-bit values
;; Uses the negative path if MSB (bit 15) is set
(defun number-to-chunks (num)
  (let* ((fat (logand num #xFFFF))           ;; Ensure 16-bit
         ;; Split the value into three chunks
         (out0 (logand (ash fat -12) #xF))    ;; (fat & 0xF000) >> 12
         (out1 (logand (ash fat -6) #x3F))    ;; (fat & 0x0FC0) >> 6
         (out2 (logand fat #x3F))             ;; fat & 0x003F
         ;; Check if MSB (bit 15) is set
         (is-negative (not (zerop (logand fat #x8000)))))

    (if is-negative
        ;; Negative path (if self.negative)
        (cond
          ;; if outs[0] == 0xF and outs[1] == 0x3F and outs[2] & 0x20: return [outs[2]]
          ((and (= out0 #xF)
                (= out1 #x3F)
                (not (zerop (logand out2 #x20))))
           (list out2))

          ;; if outs[0] == 0xF and outs[1] == 0x3F and not (outs[2] & 0x20): return [0x3F, outs[2]]
          ((and (= out0 #xF)
                (= out1 #x3F)
                (zerop (logand out2 #x20)))
           (list #x3F out2))

          ;; if outs[0] == 0xF and outs[1] & 0x20: return outs[1:3]
          ((and (= out0 #xF)
                (not (zerop (logand out1 #x20))))
           (list out1 out2))

          ;; return [outs[1], outs[0], outs[2]]
          (t (list out1 out0 out2)))

      ;; Else path (not negative)
      (cond
        ;; if outs[0] == 0x0 and outs[1] == 0x00 and not (outs[2] & 0x20): return [outs[2]]
        ((and (= out0 #x0)
              (= out1 #x00)
              (zerop (logand out2 #x20)))
         (list out2))

        ;; if outs[0] == 0x0 and outs[1] == 0x00 and outs[2] & 0x20: return [0, outs[2]]
        ((and (= out0 #x0)
              (= out1 #x00)
              (not (zerop (logand out2 #x20))))
         (list 0 out2))

        ;; if outs[0] == 0x0 and not (outs[1] & 0x20): return outs[1:3]
        ((and (= out0 #x0)
              (zerop (logand out1 #x20)))
         (list out1 out2))

        ;; return [outs[1], outs[0], outs[2]]
        (t (list out1 out0 out2))))))



; Opcodes.
(defconstant opcode-a*>d #b00 "Move value in address a to d")
(defconstant opcode-a>d  #b01 "Move literal a to d")
(defconstant opcode-d>a* #b10 "Move d to address a")
(defconstant opcode-push #b11 "Push literal chunk to a")

(defconstant reg-iplo #x0 "Instruction pointer, low byte")
(defconstant reg-iphi #x1 "Instruction pointer, high byte")
(defconstant reg-looplo #x2 "Loop register, low byte")
(defconstant reg-loophi #x3 "Loop register, high byte")
(defconstant reg-indilo #x4 "Indirect register, low byte")
(defconstant reg-indihi #x5 "Indirect register, high byte")
(defconstant reg-nand #x6 "Bitwise NAND of IndiLo and IndiHi")
(defconstant reg-flow #x7 "Processor control flow bits")

(defconstant flow-sixteen-wide #x01 "")
(defconstant flow-inhibit-if-zero #x02 "")
(defconstant flow-loop-down #x04 "")
(defconstant flow-indirect-up #x08 "")
(defconstant flow-store-indirect #x10 "")
(defconstant flow-load-indirect #x20 "")
(defconstant flow-indirect-down #x40 "")
(defconstant flow-unused #x80 "")


; Stick a single raw instruction together.
(defun assemble-one-raw-instruction (opcode data)
  (logand #xFF (logior (ash (logand opcode #x3) 6) (logand data #x3F))))

; Stick several raw instructions together, autopushing values as necessary.
(defun build-raw-instructions (opcode data)
  (append
    (when (> (length data) 1) 
      ; Push high chunks first.
      (mapcar (lambda (d) (assemble-one-raw-instruction opcode-push d)) (reverse (cdr (reverse data))))
    )
    (list (assemble-one-raw-instruction opcode (car (last data))))
  )
)

; Primitive instruction types, including "push" for the deranged.
(defun a*>d (addr) (build-raw-instructions opcode-a*>d (number-to-chunks addr)))
(defun a>d (val) (build-raw-instructions opcode-a>d (number-to-chunks val)))
(defun d>a* (addr) (build-raw-instructions opcode-d>a* (number-to-chunks addr)))
(defun push-a (val) (assemble-one-raw-instruction opcode-push val))

(defun is-primitive (stm) (if (listp stm) (member (car stm) '(a*>d a>d d>a* push-a)) nil))

; Objects need type information. These functions provide it.
; Types are :val (value), :ptr (pointer), :wid (wide pointer), :ind (indirect)
(defun no-type (val) (if (listp val) (car val) val))
(defun as-type (typ val) (list (no-type val) typ))
(defun extract-type (val) (if (listp val) (car (cdr val)) :val))
(defun is-type (typ val) (eq typ (extract-type val)))

; Special registers. They carry some type information.
; TODO: pointer types for the main registers please
(defconstant reg-ip (as-type :wid reg-iplo))
(defconstant reg-loop (as-type :wid reg-looplo))
(defconstant reg-indi (as-type :wid reg-indilo))

; Macroland below. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; Specificity - loop-for, do-flow, etc.
; These macros expand into trees of primitive statements that can later be mapcar'd into a binary.
; Actually they're functions now. I wanted the terms to be evaluated. But that's OK. 
; Shhhhhhh.

; Set flags.
(defun do-flow (mask) `((a>d ,mask) (d>a* ,reg-flow)))

; Semi-primitive move operation.
(defun do-move (flags left right)
  ; Might need to set flags.
  (let* ((cflags flags)
         (cflags (if (is-type :ind left) (logior cflags flow-load-indirect) cflags))
         (cflags (if (is-type :ind right) (logior cflags flow-store-indirect) cflags))
         (cflags (if (is-type :wid left) (logior cflags flow-sixteen-wide) cflags))
         (cflags (if (is-type :wid right) (logior cflags flow-sixteen-wide) cflags)))
    ; Anatomy of a move: set flags, move to D, then move out of D.
    `(,@(if (not (eq cflags 0)) (do-flow cflags))
      (,(if (or (is-type :ptr left) (is-type :wid left)) 'a*>d 'a>d) ,(no-type left))
      (d>a* ,(no-type right))
      )
  )
)

; Basic "move number" instructions, conditional or not.
(defun move (left right) (do-move 0 left right))
(defun move-if (left right) (do-move flow-inhibit-if-zero left right))

; Basic data block - just copy a list of bytes into the binary.
; lol actually just use "list"

; Jumping.
(defun jump-to (addr) (move addr (as-type :wid reg-ip)))
(defun jump-if (addr) (move-if addr (as-type :wid reg-ip)))

; Preprocessor blanks.
(defun at-origin (v) nil)

; Assemblerland below. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; Functions to assemble a list of primitives into a binary.
(defun flatten (struct) 
  (cond ((null struct) nil) 
        ((atom struct) (list struct)) 
        (t (mapcan #'flatten struct))))

(defun assemble (statements) (flatten (mapcar #'eval statements)))

; Just for the record: my plan to solve this was a dynamic "defun" with auto-assembled symbol names.
; It didn't work and I'm cross about it. I blame my tools.

(defparameter *label-mapping* (make-hash-table :test 'equalp))  ; this test func is a case-insensitive string comparison

(defun label (key) (gethash key *label-mapping*))
(defun label-set (key val) (setf (gethash key *label-mapping*) val))

; Inflation pass: convert complex statements into primitives.
; I feel as though this could be more elegant
(defun inflation-pass (statements)
  (apply #'append
    (mapcar (lambda (stm)
      (if (is-primitive (car (eval stm))) (eval stm) (list stm))
    )
    statements)
  )
)
; Label pass: run through a program and determine the width of all labels present.
(defun label-pass (statements)
  (let* ((current-origin 0))
    (mapcar (lambda (stm)
      ; Fill the label with a convincing dummy value.
      (cond 
        ((eq 'label (car stm)) (label-set (car (cdr stm)) #xeaea))
        ((eq 'at-origin (car stm)) (setq current-origin (car (cdr stm))))
      )
    )
    statements)
  )
)

; Spacing pass: eval statements to figure out where the labels should go
(defun spacing-pass (statements)
  (let* ((current-origin 0))
    (mapcar (lambda (stm)
      (cond
        ((eq 'label (car stm)) (label-set (car (cdr stm)) current-origin))
        ((eq 'at-origin (car stm)) (setq current-origin (car (cdr stm))))
        (t (setq current-origin (+ current-origin (length (eval stm)))))
      )
    )
    statements)
  )
)

; Binary pass: eval statements to produce a binary.
(defun binary-pass (statements)
  (let* ((current-origin 0))
    (mapcar (lambda (stm)
      (cond
        ((eq 'label (car stm)) )
        ((eq 'at-origin (car stm)) )
        (t (eval stm))
      )
    )
    statements)
  )
)

(defvar *src-code* 
  '(
    (at-origin #x0010)
    (label "Datums")
    (list 11 22 33 44 55)

    (at-origin #x8000)
    (label "BlitStart")
    (move 16384 reg-indi)
    (move 1024 reg-loop)
    
    (label "BlitLoop")
    (move (as-type :ptr 17410) (as-type :ind reg-indilo))
    (do-flow (logior flow-loop-down flow-indirect-up))
    (jump-if (label "BlitLoop"))

    (do-flow flow-unused)
    (jump-to (label "BlitStart"))
))


